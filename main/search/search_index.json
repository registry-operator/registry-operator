{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to Registry Operator's documentation portal! Here, you'll find everything you need, whether you're a beginner getting started with container registries or an experienced user looking for advanced operational features.</p> <p>The Registry Operator simplifies the management of your container registry, automating tasks such as scaling, updates, and backups, allowing you to focus more on your application development and less on operational overhead. It provides seamless integration with Kubernetes, utilizing Custom Resource Definitions (CRDs) and Operator pattern to ensure the health and scalability of your registry infrastructure.</p>"},{"location":"#what-is-the-distribution-registry","title":"What is the Distribution Registry?","text":"<p>The Distribution Registry, often simply called the Registry, is a stateless, highly scalable server-side application that stores and distributes container images and other content.<sup>1</sup> It's a core component of the container ecosystem, allowing you to push, pull, and manage container images efficiently across environments. With Registry Operator, managing this core service becomes easier, more automated, and scalable.</p>"},{"location":"#key-features-of-registry-operator","title":"Key Features of Registry Operator","text":"<ul> <li>Automated Lifecycle Management: The operator manages the lifecycle of your container registry, from installation and configuration to updates and maintenance.</li> <li>Custom Resource Definitions (CRDs): Leverage Kubernetes-native resources to define and manage your registry instances.</li> <li>Easy Installation and Configuration: With simple installation steps and clear configuration options, setting up a registry is fast and efficient.</li> </ul> <ol> <li> <p>https://distribution.github.io/distribution/ \u21a9</p> </li> </ol>"},{"location":"design/architecture/design-draft/","title":"Design Draft","text":""},{"location":"design/architecture/design-draft/#overview","title":"Overview","text":"<p>The Registry Operator is being developed to simplify the management and operation of CNCF Distribution Registry instances within Kubernetes environments. It automates tasks such as deployment, scaling and upgrades of container image registries. By providing a streamlined and automated approach, the Registry Operator aims to enhance the developer and DevOps experience, reduce operational overhead, and ensure the registry remains highly available and performant.</p>"},{"location":"design/architecture/design-draft/#problem-statement","title":"Problem Statement","text":"<p>Managing stateful applications like container image registries manually in Kubernetes can be challenging due to various reasons:</p> <ol> <li> <p>Complexity in Configuration: Setting up and managing a container registry requires configuration of various components such as storage, networking, and access controls. Manually managing these configurations can lead to inconsistencies and errors.</p> </li> <li> <p>Scaling and Upgrades: Without an automated process, scaling registry instances or upgrading them becomes time-consuming and prone to downtime or misconfiguration.</p> </li> <li> <p>Monitoring and Alerts: Manually setting up monitoring for registry health and performance can be inefficient, and failure to detect issues early may result in downtime.</p> </li> </ol> <p>The Registry Operator addresses these pain points by automating these tasks, ensuring reliable and efficient operation of container image registries in Kubernetes.</p>"},{"location":"design/architecture/design-draft/#objectives","title":"Objectives","text":"<p>The primary objectives of the Registry Operator are as follows:</p> <ol> <li> <p>Automate Deployment and Configuration: </p> <ul> <li>Simplify the process of deploying CNCF Distribution Registry instances by automating the configuration of storage, networking, and access controls.</li> <li>Provide a declarative approach using Kubernetes Custom Resource Definitions (CRDs) to manage registry instances.</li> </ul> </li> <li> <p>Seamless Scaling and Upgrades: </p> <ul> <li>Ensure that scaling the registry to meet demand can be done effortlessly, without manual intervention.</li> <li>Support zero-downtime upgrades for registry instances, ensuring business continuity during version changes.</li> </ul> </li> <li> <p>High Availability and Fault Tolerance:</p> <ul> <li>Ensure the registry remains highly available, even during node failures or resource limitations.</li> <li>Build in self-healing mechanisms to automatically recover from common failure scenarios.</li> </ul> </li> <li> <p>Monitoring and Alerting: </p> <ul> <li>Integrate with popular monitoring tools (e.g., Prometheus, Grafana) to provide real-time health metrics, performance monitoring, and usage statistics.</li> <li>Automate alerting to notify administrators of critical issues before they impact operations.</li> </ul> </li> <li> <p>Secure and Compliant Operations: </p> <ul> <li>Enforce security best practices for managing access controls, securing registry communication, and handling sensitive data.</li> <li>Ensure compliance with industry standards and organizational policies for container registry management.</li> </ul> </li> <li> <p>Ease of Use for DevOps Teams:</p> <ul> <li>Provide clear documentation and user-friendly interfaces for configuring and managing registry instances.</li> <li>Offer seamless integration with CI/CD pipelines to enhance DevOps workflows, allowing quick and efficient management of container images.</li> </ul> </li> </ol>"},{"location":"design/architecture/design-draft/#mvp-minimum-viable-product","title":"MVP (Minimum Viable Product)","text":""},{"location":"design/architecture/design-draft/#core-features","title":"Core Features","text":""},{"location":"design/architecture/design-draft/#custom-resource-definitions","title":"Custom Resource Definitions","text":"<pre><code>---\napiVersion: registry-operator.dev/v1alpha1\nkind: Registry\nmetadata:\n  name: my-registry\nspec:\n  replicas: 3          # Number of registry instances\n  image: registry:2    # The container image for the registry\n\n  storage:\n    bucketClassName: my-s3-class              # Name of the BucketClass for which the BucketClaim and Bucket are provisioned\n    bucketAccessClass: my-s3-access-class     # Name of the BucketAccessClass for which the BucketAccess and Secret are provisioned\n\n  resources:\n    requests:\n      cpu: \"500m\"      # CPU resource requests\n      memory: \"1Gi\"    # Memory resource requests\n    limits:\n      cpu: \"1\"         # CPU resource limits\n      memory: \"2Gi\"    # Memory resource limits\n\n  service:\n    type: ClusterIP    # Kubernetes service type (can be ClusterIP, NodePort, or LoadBalancer)\n    port: 5000         # Port for the registry service\n</code></pre>"},{"location":"design/architecture/design-draft/#controller-logic","title":"Controller Logic","text":"<p>The Registry Operator controller is designed to ensure that the state of the container registry aligns with the desired configuration specified in the <code>Registry</code> CRD. It continuously monitors the state of both the custom resource and its dependencies, performing reconciliation as necessary to maintain the desired state.</p> <p>Key Responsibilities:</p> <ol> <li> <p>Observe State:</p> <ul> <li>The controller continuously observes the state of the <code>Registry</code> CRD and its dependent resources, including Deployments, Services, etc.</li> </ul> </li> <li> <p>Handle State Changes:</p> <ul> <li>When any observed resource changes state (e.g., due to updates, failures, or scaling events), the controller is notified and takes appropriate action to reconcile the state.</li> </ul> </li> <li> <p>Reconcile State:</p> <ul> <li>The controller performs reconciliation operations to ensure that the actual state of the registry matches the desired state defined in the <code>Registry</code> CRD. This includes creating, updating, or deleting resources as necessary.</li> </ul> </li> <li> <p>Integration with Dependencies:</p> <ul> <li>The controller manages the lifecycle of related Kubernetes resources:<ul> <li>Deployment: Ensures the registry pods are correctly deployed and scaled.</li> <li>Service: Manages access to the registry within the cluster.</li> <li>BucketClaim and BucketAccess: Manages storage for the registry.</li> </ul> </li> </ul> </li> </ol> <p>Sequence Diagram:</p> <pre><code>sequenceDiagram\n    participant CustomResource\n    participant Controller\n    participant BucketClaim\n    participant BucketAccess\n    participant Deployment\n    participant Service\n\n    Controller-&gt;&gt;CustomResource: observe state\n    loop\n        CustomResource--&gt;&gt;Controller: state change\n        Controller-&gt;&gt;+BucketClaim: reconcile state\n        BucketClaim--&gt;&gt;-Controller: desired state\n        Controller-&gt;&gt;+BucketAccess: reconcile state\n        BucketAccess--&gt;&gt;-Controller: desired state\n        Controller-&gt;&gt;+Deployment: reconcile state\n        Deployment--&gt;&gt;-Controller: desired state\n        Controller-&gt;&gt;+Service: reconcile state\n        Service--&gt;&gt;-Controller: desired state\n    end</code></pre> <p>Workflow:</p> <ol> <li> <p>Initial Observation:</p> <ul> <li>The controller starts by observing the state of the <code>Registry</code> CRD and related resources. It monitors any changes or updates.</li> </ul> </li> <li> <p>Reconciliation Loop:</p> <ul> <li>Whenever a state change is detected in the <code>Registry</code> CRD or its dependencies, the controller triggers a reconciliation loop.</li> <li>In this loop, the controller:<ul> <li>Updates or creates <code>BucketClaim</code> and <code>BucketAccess</code> resources to meet the storage requirements.</li> <li>Adjusts the <code>Deployment</code> to ensure the registry pods are running as desired.</li> <li>Configures the <code>Service</code> to provide access to the registry.</li> </ul> </li> </ul> </li> <li> <p>Ensure Desired State:</p> <ul> <li>The controller continuously ensures that all related resources align with the desired state specified in the <code>Registry</code> CRD.</li> </ul> </li> </ol>"},{"location":"design/architecture/design-draft/#basic-health-checks","title":"Basic Health Checks","text":"<p>Basic Health Checks are crucial for ensuring that the container registry is operational and performing as expected. For the MVP, the health check mechanisms will include:</p> <ol> <li> <p>Pod Health Checks:</p> <ul> <li>Liveness Probes: The controller will ensure that the registry pods have liveness probes configured. These probes will periodically check that the registry service is running and responsive.</li> <li>Readiness Probes: The controller will also configure readiness probes to ensure that the registry pods are ready to serve traffic before routing requests to them.</li> </ul> </li> <li> <p>Service Health Checks:</p> <ul> <li>Service Availability: The controller will check that the Kubernetes Service for the registry is correctly exposing the registry pods and that the service endpoints are available.</li> </ul> </li> <li> <p>Custom Metrics:</p> <ul> <li>Basic Metrics Collection: The operator will expose basic metrics (e.g., request count, error rate) that can be collected by monitoring systems like Prometheus. These metrics will help in identifying potential issues and monitoring the overall health of the registry.</li> </ul> </li> </ol> <pre><code>graph TD\n    A[Pod Health Checks]\n    A --&gt; B[Liveness Probes]\n    A --&gt; C[Readiness Probes]\n\n    D[Service Health Checks] --&gt; E[Service Availability]\n\n    G[Custom Metrics] --&gt; H[Basic Metrics Collection]</code></pre>"},{"location":"design/architecture/design-draft/#deliverables","title":"Deliverables","text":"<ul> <li>Deployed operator with CRD definitions and basic lifecycle management.</li> <li>Documentation and user guides for deploying and using the operator.</li> <li>Initial test suite for core features.</li> </ul>"},{"location":"design/architecture/design-draft/#next-steps-post-mvp-enhancements","title":"Next Steps (Post-MVP Enhancements)","text":""},{"location":"design/architecture/design-draft/#registry-template","title":"Registry Template","text":"<p>To enhance flexibility and reduce duplication, the operator can introduce a <code>RegistryTemplate</code> CRD. This allows defining common configuration settings in a template that can be referenced and overridden in individual <code>Registry</code> instances.</p> <pre><code>---\napiVersion: registry-operator.dev/v1alpha1\nkind: RegistryTemplate\nmetadata:\n  name: my-registry-template  # Global template name, not namespaced\nspec:\n  replicas: 3                 # Default number of registry instances\n  image: registry:2           # Default container image for the registry\n\n  storage:\n    bucketClassName: my-s3-class              # Name of the BucketClass for which the BucketClaim and Bucket are provisioned\n    bucketAccessClass: my-s3-access-class     # Name of the BucketAccessClass for which the BucketAccess and Secret are provisioned\n\n  resources:\n    requests:\n      cpu: \"500m\"      # Default CPU resource requests\n      memory: \"1Gi\"    # Default memory resource requests\n    limits:\n      cpu: \"1\"         # Default CPU resource limits\n      memory: \"2Gi\"    # Default memory resource limits\n\n  service:\n    type: ClusterIP    # Default service type\n    port: 5000         # Default port for the service\n---\napiVersion: registry-operator.dev/v1alpha1\nkind: Registry\nmetadata:\n  name: my-registry\ntemplate: my-registry-template # Reference to the global template\nspec:\n  replicas: 5          # Override default replicas\n</code></pre>"},{"location":"design/architecture/design-draft/#how-it-works","title":"How It Works:","text":"<ol> <li> <p>Define Template: Create a <code>RegistryTemplate</code> resource that includes common settings and defaults for the registry.</p> </li> <li> <p>Reference Template: Create <code>Registry</code> resources that reference the <code>RegistryTemplate</code> by name. Specific fields in the <code>Registry</code> CRD can override default values defined in the template.</p> </li> <li> <p>Apply Overrides: The operator applies the template values and overrides from the <code>Registry</code> specification to configure the registry instances.</p> </li> </ol> <p>This approach streamlines configuration management, reduces duplication, and provides a centralized way to manage common settings for multiple registry instances.</p>"},{"location":"design/architecture/design-draft/#pull-through-cache","title":"Pull-through Cache","text":"<p>To support pull-through caching for container images, the Registry Operator will introduce a <code>Cache</code> resource. This resource will allow configuring an external cache for registry images, enabling the registry to cache and serve images from a specified upstream registry.</p> <p>For the MVP, the pull-through cache only supports using an empty path volume, and does not support PersistentVolumeClaims (PVCs) or object storage solutions.</p> <p>Cache CRD Definition:</p> <pre><code>---\napiVersion: registry-operator.dev/v1alpha1\nkind: Cache\nmetadata:\n  name: my-cache\nspec:\n  # URL of the upstream registry to cache images from\n  upstreamRegistryURL: \"https://my-upstream-registry.com\"\n\n  # Configuration for the cache volume\n  volume:\n    type: emptyDir       # Type of volume used for caching (supports ONLY emptyDir)\n    size: 50Gi           # Size of the volume (optional, for reference)\n    accessMode: ReadWriteOnce # Access mode for the volume (optional, for reference)\n\n  # Optional configurations for cache behavior\n  cacheTTL: \"24h\"       # Time-to-live for cached images\n  maxCacheSize: \"100Gi\" # Maximum cache size\n</code></pre>"},{"location":"design/architecture/design-draft/#how-it-works_1","title":"How It Works:","text":"<ol> <li> <p>Cache Configuration:</p> <ul> <li>Define a <code>Cache</code> resource with the URL of the upstream registry and the volume configuration. The registry operator will set up the cache based on this configuration.</li> </ul> </li> <li> <p>Image Caching:</p> <ul> <li>When a request for an image is made, the registry will first check the cache. If the image is not present in the cache, it will be pulled from the upstream registry and stored in the cache.</li> </ul> </li> <li> <p>Cache Management:</p> <ul> <li>The operator manages the cache based on the TTL and size settings. Cached images will be refreshed or removed according to these policies.</li> </ul> </li> <li> <p>Volume Handling:</p> <ul> <li>The <code>emptyDir</code> volume provides a temporary storage space for cached images.</li> </ul> </li> </ol>"},{"location":"design/architecture/design-draft/#advanced-features","title":"Advanced Features","text":"<ol> <li> <p>Automated Upgrades</p> <ul> <li>Support rolling updates for application deployments.</li> <li>Strategy for Automating Application Upgrades:<ul> <li>The operator will leverage Kubernetes' built-in rolling update mechanism to ensure minimal disruption during upgrades.</li> <li>A phased approach will be adopted:<ol> <li>Version Validation: The operator will first validate the target version to ensure compatibility with the current registry setup.</li> <li>Health Checks: Post-upgrade, the operator will perform health checks on each instance to ensure that it has been upgraded successfully and is functioning as expected.</li> <li>Rollback Mechanism: In case of any issues during the upgrade process, the operator will support automatic rollback to a previous stable version to ensure continuity of service.</li> </ol> </li> </ul> </li> </ul> </li> <li> <p>Use Redis (or OSS alternative) as a metadata cache</p> <ul> <li>By default, the registry stores layer metadata in an in-memory map. The operator will add support for configuring Redis or compatible open-source alternatives (e.g., Valkey, Garnet, Dragonfly, KeyDB) to store and access metadata.</li> <li>Benefits:<ul> <li>Improved performance in multi-instance, high-availability (HA) setups by externalizing the metadata store.</li> <li>Redis or its alternatives provide persistent storage of metadata, reducing the overhead on memory usage in long-running deployments.</li> </ul> </li> <li>Optional Redis Deployment:<ul> <li>If a Redis (or compatible store) is not already available, the operator can optionally provision one in the cluster.</li> <li>The Redis service can be deployed with high-availability configurations as needed by the registry's workload.</li> </ul> </li> </ul> </li> <li> <p>Provision TLS certificates with cert-manager</p> <ul> <li>The operator will integrate with cert-manager to provision and manage TLS certificates automatically.</li> <li>Key Details:<ul> <li>Cert-manager will issue certificates for the registry Ingress, ensuring secure HTTPS communication.</li> <li>The operator will manage certificate renewal and ensure that the registry always has a valid TLS certificate.</li> <li>Certificates can be automatically rotated when they expire or are nearing expiration.</li> </ul> </li> </ul> </li> <li> <p>Provision local storage for the registry with filesystem storage</p> <ul> <li>The operator will support configuring the registry to use local storage through PersistentVolumeClaims (PVCs) with filesystem storage.</li> <li> <p>Use Case:</p> <ul> <li>While PVC-based filesystem storage does not allow for HA deployments due to its stateful nature, it is still useful for certain registry setups, such as pull-through caches. This is particularly beneficial when high-performance local storage is provisioned.</li> <li>This feature is especially helpful for environments where HA is not a strict requirement or for scenarios requiring fast, local storage for cached images.</li> </ul> </li> <li> <p>Configuration:</p> <ul> <li>The operator will allow specifying a PVC for the registry, which will be automatically created and bound to the registry deployment.</li> <li>If using filesystem storage, the operator will ensure that the deployment is properly configured to avoid conflicts with HA setups, such as ensuring that the replica count is set to 1 for non-distributed setups.</li> <li>The filesystem storage option provides a simplified, cost-effective approach for users needing local caching.</li> </ul> </li> </ul> </li> </ol> <p>These advanced features will enhance the registry operator\u2019s flexibility, supporting more complex deployment scenarios and advanced caching mechanisms to optimize performance and reliability.</p>"},{"location":"design/architecture/design-draft/#testing-and-validation","title":"Testing and Validation","text":"<p>To ensure the Registry Operator is robust, scalable, and reliable, comprehensive testing will be conducted post-MVP. The testing strategy will focus on covering edge cases, scaling scenarios, and integration points with Kubernetes.</p> <ol> <li> <p>Comprehensive Testing Strategy:</p> <ul> <li>Unit Testing: <ul> <li>Each operator function (e.g., deployment, backup, scaling) will be unit tested to ensure individual components work as expected.</li> </ul> </li> <li>Integration Testing:<ul> <li>Test interactions between the operator and Kubernetes components (e.g., CRDs, controllers, volumes).</li> <li>Validate the operator's integration with external tools such as monitoring systems (e.g., Prometheus), cloud storage, and CI/CD pipelines.</li> </ul> </li> <li>Edge Case Testing:<ul> <li>Simulate scenarios such as node failures, storage disruptions, and misconfigurations to ensure the operator can handle and recover from such events.</li> <li>Test operator behavior during network outages or degraded performance to ensure high availability mechanisms are functioning properly.</li> </ul> </li> <li>Scaling Tests:<ul> <li>Validate the operator\u2019s ability to scale the registry horizontally to meet increased demand.</li> <li>Test for resource exhaustion scenarios (e.g., when CPU, memory, or storage limits are reached) to ensure that scaling, alerting, and self-healing mechanisms work correctly.</li> </ul> </li> </ul> </li> <li> <p>End-to-End (E2E) Testing with Kyverno Chainsaw:</p> <ul> <li>Kyverno Chainsaw will be used for E2E testing to simulate real-world registry operations, ensuring that the entire lifecycle of the registry is properly validated. This includes:<ul> <li>Automated Deployments: Testing the full deployment flow of the registry from configuration to startup.</li> <li>Scaling and Upgrades: Verifying that the operator can handle rolling upgrades and scaling operations without downtime.</li> <li>Backup and Recovery: Ensuring that snapshot creation, backup storage, and recovery functions work as intended in various scenarios.</li> </ul> </li> </ul> </li> <li> <p>Performance and Load Testing:</p> <ul> <li>Simulate high traffic and large-scale operations to measure performance and resource utilization.</li> <li>Ensure the operator can maintain acceptable performance levels under heavy load, large numbers of container images, or numerous concurrent users.</li> </ul> </li> </ol>"},{"location":"design/architecture/design-draft/#future-integrations","title":"Future Integrations","text":""},{"location":"design/architecture/design-draft/#runbooks","title":"Runbooks","text":"<ol> <li> <p>Authentication</p> <ul> <li>The operator will integrate with common authentication mechanisms such as OAuth2, LDAP, and Kubernetes secrets for secure access to the container registry. It will manage authentication configurations and ensure that users and services can interact securely with the registry. Future plans include:<ul> <li>Support for token-based authentication.</li> <li>Automated management of credentials and certificates.</li> <li>Integration with Kubernetes Role-Based Access Control (RBAC) for fine-grained access control.</li> </ul> </li> </ul> </li> <li> <p>Integration with UI</p> <ul> <li>The operator will integrate with the Docker Registry UI, providing a graphical interface for managing and browsing container images. This integration will allow users to:<ul> <li>View and manage image tags.</li> <li>Monitor registry activity and status through the UI.</li> <li>Perform image lifecycle management (e.g., deletion, retagging) directly from the interface.</li> </ul> </li> </ul> </li> <li> <p>Integration with ImagePuller Operator</p> <ul> <li>The Registry Operator will integrate with the ImagePuller Operator, which pre-pulls container images into Kubernetes clusters for faster deployments. The key benefits of this integration include:<ul> <li>Coordinated image management between the registry and clusters, ensuring that images are available where and when needed.</li> <li>Enhanced efficiency by reducing the time required to pull images during deployment.</li> <li>Automated syncing of images between the registry and Kubernetes nodes.</li> </ul> </li> </ul> </li> <li> <p>Alerting and Prometheus Integration</p> <ul> <li>The Registry Operator will be integrated with Prometheus for real-time monitoring and alerting. Key metrics like registry availability, image pull times, disk usage, and error rates will be exposed. Future plans include:<ul> <li>Configurable alert thresholds for key metrics, ensuring that operators are notified of potential issues before they impact the system.</li> <li>Alerts for critical events like image pull failures, storage limits, and registry health.</li> </ul> </li> </ul> </li> <li> <p>Grafana Dashboards</p> <ul> <li>The operator will include pre-configured Grafana dashboards to visualize registry performance, usage, and health. These dashboards will offer:<ul> <li>Real-time views of registry traffic, including image pulls and pushes.</li> <li>Insights into resource utilization (e.g., CPU, memory, disk usage).</li> <li>Historical trends to help operators understand usage patterns and anticipate future needs.</li> <li>Customizable panels for specific metrics that align with the organization\u2019s monitoring requirements.</li> </ul> </li> </ul> </li> </ol>"},{"location":"getting_started/0-introduction/","title":"Introduction","text":""},{"location":"getting_started/0-introduction/#understanding-operators","title":"Understanding Operators","text":"<p>Operators are a method of packaging, deploying, and managing a Kubernetes application. They automate operational tasks, like scaling, backups, updates, and more, through custom controllers that extend Kubernetes functionality. In simpler terms, an Operator watches over your resources and ensures your application maintains a desired state by automating routine tasks.</p>"},{"location":"getting_started/0-introduction/#installing-the-operator","title":"Installing the Operator","text":""},{"location":"getting_started/0-introduction/#using-kustomization","title":"Using kustomization","text":"<p>This method applies the latest configuration by fetching the latest release tag from GitHub.</p> <pre><code>LATEST=\"$(curl -s 'https://api.github.com/repos/registry-operator/registry-operator/releases/latest' | jq -r '.tag_name')\"\nkubectl apply -k \"https://github.com/registry-operator/registry-operator//config/default?ref=${LATEST}\"\n</code></pre>"},{"location":"getting_started/0-introduction/#using-release-manifests","title":"Using release manifests","text":"<p>Alternatively, you can deploy the operator using the release manifest directly from GitHub.</p> <pre><code>LATEST=\"$(curl -s 'https://api.github.com/repos/registry-operator/registry-operator/releases/latest' | jq -r '.tag_name')\"\nkubectl apply -f \"https://github.com/registry-operator/registry-operator/releases/download/${LATEST}/registry-operator.yaml\"\n</code></pre>"},{"location":"getting_started/0-introduction/#updating-the-operator","title":"Updating the Operator","text":"<p>To update to the latest version, rerun the installation command for your chosen method.</p>"},{"location":"getting_started/1-quickstart/","title":"Quick Start","text":""},{"location":"getting_started/1-quickstart/#deploying-the-simplest-registry","title":"Deploying the simplest Registry","text":"<p>The simplest possible way to create a Registry instance is by creating a YAML file like the following example. This will install the Registry using default latest<sup>1</sup> image in a single pod, using in-memory storage by default, with a <code>ClusterIP</code> service.</p> <pre><code>apiVersion: registry-operator.dev/v1alpha1\nkind: Registry\nmetadata:\n  name: simplest\n</code></pre> <p>The YAML file can then be used with <code>kubectl</code>:</p> <pre><code>kubectl apply -f simplest.yaml\n</code></pre> <p>In a few seconds, a new in-memory instance of Registry will be available, suitable for quick demos and development purposes. To check the instances that were created, list the Registry objects:</p> <pre><code>$ kubectl get registries.registry-operator.dev \nNAME       VERSION      READY   IMAGE\nsimplest   3.0.0-rc.3   true    docker.io/library/registry:3.0.0-rc.3\n</code></pre> <p>To get the deplpyment name, query for the deployments belonging to the simplest Registry instance:</p> <pre><code>$ kubectl get deployments.apps -l=app.kubernetes.io/instance=default.simplest\nNAME                READY   UP-TO-DATE   AVAILABLE   AGE\nsimplest-registry   1/1     1            1           2m\n</code></pre> <p>To get the service name, query for the services belonging to the simplest Registry instance:</p> <pre><code>$ kubectl get services -l=app.kubernetes.io/instance=default.simplest\nNAME                TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE\nsimplest-registry   ClusterIP   10.96.187.2   &lt;none&gt;        5000/TCP   2m\n</code></pre> <p>Similarly, the logs can be queried from all pods belonging to our instance:</p> <pre><code>$ kubectl logs -l app.kubernetes.io/instance=default.simplest\ntime=\"2024-10-09T08:11:02.799689427Z\" level=warning msg=\"No HTTP secret provided - generated random secret. This may cause problems with uploads if multiple registries are behind a load-balancer. To provide a shared secret, fill in http.secret in the configuration file or set the REGISTRY_HTTP_SECRET environment variable.\" go.version=go1.20.8 instance.id=8ab1846a-75f9-4ac0-840e-4876165f56b2 service=registry version=3.0.0-rc.3 \ntime=\"2024-10-09T08:11:02.799779511Z\" level=info msg=\"redis not configured\" go.version=go1.20.8 instance.id=8ab1846a-75f9-4ac0-840e-4876165f56b2 service=registry version=3.0.0-rc.3 \ntime=\"2024-10-09T08:11:02.800089011Z\" level=info msg=\"using inmemory blob descriptor cache\" go.version=go1.20.8 instance.id=8ab1846a-75f9-4ac0-840e-4876165f56b2 service=registry version=3.0.0-rc.3 \ntime=\"2024-10-09T08:11:02.800370261Z\" level=info msg=\"listening on [::]:5000\" go.version=go1.20.8 instance.id=8ab1846a-75f9-4ac0-840e-4876165f56b2 service=registry version=3.0.0-rc.3 \ntime=\"2024-10-09T08:11:02.800428594Z\" level=info msg=\"Starting upload purge in 16m0s\" go.version=go1.20.8 instance.id=8ab1846a-75f9-4ac0-840e-4876165f56b2 service=registry version=3.0.0-rc.3 \n</code></pre> <ol> <li> <p>Latest image is the latest stable version available at the time of the Registry Operator release.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/out/","title":"API Reference","text":""},{"location":"reference/out/#packages","title":"Packages","text":"<ul> <li>registry-operator.dev/v1alpha1</li> </ul>"},{"location":"reference/out/#registry-operatordevv1alpha1","title":"registry-operator.dev/v1alpha1","text":"<p>Package v1alpha1 contains API Schema definitions for the registry v1alpha1 API group</p>"},{"location":"reference/out/#resource-types","title":"Resource Types","text":"<ul> <li>Registry</li> </ul>"},{"location":"reference/out/#registry","title":"Registry","text":"<p>Registry is the Schema for the registries API.</p> Field Description Default Validation <code>apiVersion</code> string <code>registry-operator.dev/v1alpha1</code> <code>kind</code> string <code>Registry</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> RegistrySpec <code>status</code> RegistryStatus"},{"location":"reference/out/#registryspec","title":"RegistrySpec","text":"<p>RegistrySpec defines the desired state of Registry.</p> <p>Appears in: - Registry</p> Field Description Default Validation <code>image</code> string Image indicates the container image to use for the Registry. <code>replicas</code> integer Replicas indicates the number of the pod replicas that will be created. <code>resources</code> ResourceRequirements Resources describe the compute resource requirements. <code>affinity</code> Affinity Affinity specifies the scheduling constraints for Pods. <code>storage</code> Storage Storage defines the available storage options for a registry.It allows specifying different storage sources to manage storage lifecycle and persistence."},{"location":"reference/out/#registrystatus","title":"RegistryStatus","text":"<p>RegistryStatus defines the observed state of Registry.</p> <p>Appears in: - Registry</p> Field Description Default Validation <code>ready</code> boolean Ready is a boolean field that is true when the Registry is ready to be used. <code>version</code> string Version of the managed Registry. <code>image</code> string Image indicates the container image to use for the Registry."},{"location":"reference/out/#s3storagesource","title":"S3StorageSource","text":"<p>S3StorageSource defines the configuration for connecting to an S3-compatible storage backend. It holds the necessary secret references to access an S3-compatible storage service.</p> <p>Appears in: - Storage</p> Field Description Default Validation <code>bucketName</code> SecretKeySelector BucketName is an optional reference to the secret key containing thedefault bucket name to be used. <code>region</code> SecretKeySelector Region is an optional reference to the secret key containing the S3region name. <code>accessKey</code> SecretKeySelector AccessKey is a reference to the secret key containing the S3 access key. <code>secretKey</code> SecretKeySelector SecretKey is a reference to the secret key containing the S3 secret key. <code>endpointURL</code> SecretKeySelector EndpointURL is an optional reference to the secret key containing anoverride for the S3 endpoint URL."},{"location":"reference/out/#secretkeyselector","title":"SecretKeySelector","text":"<p>SecretKeySelector selects a key of a Secret.</p> <p>Appears in: - S3StorageSource</p> Field Description Default Validation <code>key</code> string The key of the secret to select from. Must be a valid secret key."},{"location":"reference/out/#storage","title":"Storage","text":"<p>Storage specifies various types of storage sources that a registry can use for persistence.</p> <p>Appears in: - RegistrySpec</p> Field Description Default Validation <code>emptyDir</code> EmptyDirVolumeSource EmptyDir represents a temporary directory that shares a pod's lifetime. <code>ephemeral</code> EphemeralVolumeSource Ephemeral represents a volume that is handled by a cluster storage driver.The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,and deleted when the pod is removed. <code>hostPath</code> HostPathVolumeSource HostPath represents a directory on the host. <code>persistentVolumeClaim</code> PersistentVolumeClaimVolumeSource PersistentVolumeClaim represents a reference to a PersistentVolumeClaim in the same namespace. <code>persistentVolumeClaimTemplate</code> PersistentVolumeClaimSpec PersistentVolumeClaimTemplate allows creating PVCs dynamically.This defines a PVC template that will be instantiated for the pod. <code>s3</code> S3StorageSource S3 defines an S3-compatible storage source for persisting registry data.It provides a way to use object storage systems such as Amazon S3 or S3-compatible servicesfor data persistence. This field is optional and can be configured with an endpoint and appropriate credentials."}]}